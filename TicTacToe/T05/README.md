# Данный проект является результатом выполнения двух проектов (04 - 05), основанные на проекте T03 из текущего репозитория

# Project Backend 04 — Java_Bootcamp
Используй проект для серверной части с предыдущей недели Т03.

## Задание 1. Добавление базы данных
- Опиши подключение к базе данных PostgreSQL в application.properties.
- Избавься от класса-хранилища.
- Добавь специальные аннотации для классов, которые необходимо сохранять в базу данных.
- Используй у репозиториев в качестве родителя CrudRepository.

## Задание 2. Добавление авторизации
- Добавь пользователей, у которых будет UUID, логин, пароль.
- Реализуй поддержку пользователей на всех слоях.
- Создай модель SignUpRequest, у которой будет логин и пароль.
- Создай сервис авторизации, который использует UserService:
    - метод регистрации, который принимает SignUpRequest и возвращает факт успешной регистрации;
    - метод авторизации, который принимает в заголовке логин и пароль в виде base64(login:password) и возвращает UUID пользователя.
- Создай контроллер авторизации, у которого будут следующие endpoint'ы:
    - для регистрации пользователя;
    - для авторизации пользователя.
- Создай класс AuthFilter, сделай наследование от GenericFilterBean и реализуй метод doFilter:
    - Провалидируй логин и пароль.
    - Если валидация прошла успешно, то выполни запрос.
    - Если валидация прошла с ошибкой, то добавь в ответ 401 код и не выполняй запрос.
- Создай Spring Configuration, где:
    - Опиши Bean для получения SecurityFilterChain.
    - Разреши доступ без авторизации к endpoint'ам регистрации и авторизации.
    - Для всех остальных endpoint'ов должна требоваться авторизация.
    - Воспользуйся AuthFilter в качестве фильтра.

## Задание 3. Добавление логики игры между двумя игроками
- Добавь состояния для текущей игры:
    - ожидание игроков;
    - ход игрока с UUID;
    - ничья;
    - победа игрока с UUID.
- Добавь информацию о значках, которыми будут ходить пользователи, в текущую игру.
- Улучши алгоритм определения окончания игры с использованием состояний.
- Добавь endpoint для создания новой игры с пользователем или компьютером.
- Добавь endpoint для получения доступных текущих игр.
- Добавь endpoint для присоединения пользователя к игре.
- Улучши endpoint обновления текущей игры с учетом игры с пользователем или компьютером.
- Добавь endpoint для получения текущей игры.
- Добавь endpoint для получения информации о пользователе по UUID.


# Project Backend 05 — Java_Bootcamp
### Проект: Крестики-Нолики
Используй проект для серверной части с предыдущей недели Т04.

## Задание 1. Изменение basic авторизации на jwt
- Добавь перечисление ролей, у которого будет единственная роль USER.
- Реализуй поддержку ролей на всех слоях.
- Для доменной модели роли сделай наследование от GrantedAuthority.
- Добавь пользователям список ролей.
- Создай модель JwtRequest, у которой будет логин и пароль.
- Создай модель JwtResponse, у которой будет тип, accessToken, refreshToken.
- Создай модель RefreshJwtRequest, у которой будет refreshToken.
- Реализуй класс JwtProvider, у которого есть следующие методы:
    - для генерации токенов используй io.jsonwebtoken.Jwts.builder();
    - метод генерации accessToken по User, в токен необходимо сохранить информацию о UUID и роли в claims (в claims сохраняют часть информации об объекте для последующего использования);
    - метод генерации refreshToken по User, в токен необходимо сохранить информацию о UUID в claims;
    - метод валидации accessToken;
    - метод валидации refreshToken;
    - метод получения claims.
- Создай модель JwtAuthentication и сделай наследование от Authentication:
    - для getAuthorities() возвращай роли;
    - для getPrincipal() возвращай UUID;
    - для getName() возвращай UUID;
    - для факта авторизации сделай отдельное поле.
- Реализуй класс JwtUtil, имеющий метод создания JwtAuthentication по claims.
- Обнови сервис авторизации, который использует UserService, JwtProvider, SecurityContextHolder, для реализации следующих методов:
    - Измени метод авторизации, теперь он принимает JwtRequest и возвращает JwtResponse.
    - Создай метод обновления accessToken, который принимает refreshToken и возвращает JwtResponse.
    - Создай метод обновления refreshToken, который принимает refreshToken и возвращает JwtResponse.
    - Создай метод получения JwtAuthentication.
- Обнови контроллер авторизации, у которого добавятся или изменятся endpoint'ы:
    - для авторизации пользователя;
    - для обновления accessToken;
    - для обновления refreshToken.
- Измени поведение метода doFilter класса AuthFilter:
    - Получи токен из заголовка Authorization, который содержит "Bearer {accessToken}".
    - С помощью JwtProvider провалидируй токен.
    - С помощью JwtProvider получи claims.
    - С помощью JwtUtil создай JwtAuthentication по claims.
    - Установи авторизацию с помощью SecurityContextHolder.
- Добавь в Spring Configuration доступ без авторизации к endpoint'у обновления accessToken.
- Добавь endpoint для получения информации о пользователе по accessToken.

## Задание 2. Добавление поддержки истории игр
- Добавь в модель игры ее дату создания.
- Опиши запрос базы данных для получения всех завершенных игр по UUID пользователя.
- Игра считается завершенной, если у нее одно из состояний:
    - Победа игрока с UUID;
    - Ничья.
- Добавь в сервис для работы с играми метод для получения всех завершенных игр по UUID пользователя.
- Добавь endpoint для получения всех завершенных игр по accessToken, доступ к которому есть только у авторизованных пользователей.

## Задание 3. Добавление поддержки таблицы лидеров
- Создай модель для информации о выигранных играх, в которой будет UUID пользователя и соотношение побед.
- Опиши запрос базы данных, в котором:
    - Получи соотношение количества выигранных игр к поражениям и ничьим для каждого пользователя.
    - Отсортируй соотношение побед по убыванию.
    - Выбери первые N записей, в каждой из которых будет UUID пользователя и соотношение побед.
- Добавь в сервис для работы с играми получение первых N лучших игроков.
- Добавь endpoint для получения первых N лучших игроков, который принимает N (количество лучших игроков) и возвращает список лучших игроков (UUID и логин) с их соотношением побед.
- endpoint для получения лучших игроков должен быть доступен только авторизованным пользователям
